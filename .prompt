#!/bin/bash
#-------------------------------------------------------------------------------
# File        : .prompt
# Author      : Lewis Russell
# Description : Very useful csh/tcsh/bash prompt for seamless use with Git and
#               SVN.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Arguments
#-------------------------------------------------------------------------------
SHELL="$1"
RET_CODE="$2"

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
  GIT_ST_OPTS="--ignore-submodules"
      TIMEOUT=3
DYNAMIC_WIDTH=1

#-------------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------------
   STAGED_PATTERN="^ *A\|^M"
 UNSTAGED_PATTERN="^ \+M"
UNTRACKED_PATTERN="^ *?"

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------
check_error() {
    RET_CODE="$1"
    CODE="$2"
    if [ "$RET_CODE" != 0 ]; then
        echo "ERROR $CODE"
    fi
}

in_git() {
    git rev-parse 2> /dev/null
    return $?
}

in_svn() {
    svn ls --depth empty > /dev/null 2>&1
    return $?
}

#-------------------------------------------------------------------------------
# Attributes & Colours
#-------------------------------------------------------------------------------
if [ "$SHELL" == "bash" ]; then
    c_start="\["
      c_end="\]"
       user="\u"
        dir="\W"
else # csh/tcsh
    c_start="%{"
      c_end="%}"
       user="%n"
        dir="%c"
fi

   gray="${c_start}\e[1;30m${c_end}"
    red="${c_start}\e[1;31m${c_end}"
  green="${c_start}\e[1;32m${c_end}"
 yellow="${c_start}\e[1;33m${c_end}"
   blue="${c_start}\e[1;34m${c_end}"
magenta="${c_start}\e[1;35m${c_end}"
   cyan="${c_start}\e[1;36m${c_end}"
  white="${c_start}\e[1;37m${c_end}"
    end="${c_start}\e[0m${c_end}" # This is needed at the end.

# Use a different colour for each shell.
if [ "$SHELL" == "bash" ]; then
    dir_colour="$yellow"
else
    dir_colour="$magenta"
fi

src_ctl_colour="$gray"

#-------------------------------------------------------------------------------
# Return Code
#-------------------------------------------------------------------------------
if [ "$RET_CODE" == 0 ]; then
    ret_colour="$cyan"
else
    ret_colour="$red"
fi

#-------------------------------------------------------------------------------
# Source Control
#-------------------------------------------------------------------------------
if in_git; then
    get_git_checkout() {
        info="$1"

        checkout=$(\
            echo "$info" | \
            sed 's/\.\.\..*//g' | \
            sed -E 's/##[[:space:]]+//g' | \
            sed -n '1 p')
        check_error "$?" "5"

        if [ "$checkout" == "HEAD" ]; then
            # Show short hash if not on a branch
            checkout="HEAD:"$(git rev-parse --short HEAD)
            check_error "$?" "6"
        fi

        echo "$checkout"
    }

    has_src_ctrl=1

    info=$(timeout $TIMEOUT git status -sbu --porcelain $GIT_ST_OPTS)
    check_error "$?" "2"

     ahead=$(echo "$info" | grep 'ahead'  | sed -E  's/.*ahead[[:space:]]+([0-9]+).*/+\1/g')
    behind=$(echo "$info" | grep 'behind' | sed -E 's/.*behind[[:space:]]+([0-9]+).*/-\1/g')
    check_error "$?" "4"

    files="$info"
    checkout=$(get_git_checkout "$info")
elif in_svn; then

    get_svn_local_rev() {
        info="$1"
        echo "$info" | grep 'Revision' | sed -E 's/Revision: ([0-9]+)/\1/'
    }

    get_svn_remote_rev() {
        info="$1"

        repo=$(echo "$info" | grep 'URL' | sed -E 's/URL: (.+)/\1/')

        remote_info=$(timeout $TIMEOUT svn info $repo)
        check_error "$?" "10"

        echo "$remote_info" | grep 'Revision' | sed -E 's/Revision: ([0-9]+)/\1/'
    }

    has_src_ctrl=1
    info=$(timeout $TIMEOUT svn info)
    check_error "$?" "7"

     local_rev=$(get_svn_local_rev  "$info")
    remote_rev=$(get_svn_remote_rev "$info")

    if [[ $remote_rev =~ ^[0-9]+$ ]]; then
        behind=$(expr $remote_rev - $local_rev)
        check_error "$?" "8"

        if [ "$behind" == "0" ]; then
             behind=""
        else
             behind="-$behind"
        fi
    else
        check_error "1" "9"
    fi

    ahead="" # SVN is never ahead
    files=$(timeout $TIMEOUT svn status 2> /dev/null)
    check_error "$?" "12"

    checkout="r$local_rev"
fi

#---------------------------------------------------------------------------
# Status
#---------------------------------------------------------------------------
if [ "$has_src_ctrl" == "1" ]; then
    staged=$(echo "$files" | grep -c "$STAGED_PATTERN")
    if [ "$staged" == "0" ]; then
         staged=""
    else
         staged="+$staged"
    fi

    unstaged=$(echo "$files" | grep -c "$UNSTAGED_PATTERN")
    if [ "$unstaged" == "0" ]; then
         unstaged=""
    else
         unstaged="+$unstaged"
    fi

    untracked=$(echo "$files" | grep -c "$UNTRACKED_PATTERN")
    if [ "$untracked" == "0" ]; then
         untracked=""
    else
         untracked="+$untracked"
    fi

    src_ctrl=""
    src_ctrl+="$src_ctl_colour"
    src_ctrl+="["
    src_ctrl+="$checkout"
    src_ctrl+="$white"
    src_ctrl+="$ahead"
    src_ctrl+="$behind"
    src_ctrl+="$green"
    src_ctrl+="$staged"
    src_ctrl+="$red"
    src_ctrl+="$unstaged"
    src_ctrl+="$magenta"
    src_ctrl+="$untracked"
    src_ctrl+="$src_ctl_colour"
    src_ctrl+="]"
fi

#-------------------------------------------------------------------------------
# Prompt
#-------------------------------------------------------------------------------
prompt=""

# Adjust prompt according on terminal width.
if [ $(tput cols) -gt 80 ] || [ "$DYNAMIC_WIDTH" == 0 ]; then
    prompt+="$cyan"
    prompt+="$user:"
    prompt+="$dir_colour"
    prompt+="$dir"
fi

prompt+="$src_ctrl"
prompt+="$error"
prompt+="$ret_colour>$end "

echo "$prompt"

