#!/bin/bash
#-------------------------------------------------------------------------------
# File        : .prompt
# Author      : Lewis Russell
# Description : Very useful zsh/csh/tcsh/bash prompt for seamless use with Git
#               and SVN.
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# Arguments
#-------------------------------------------------------------------------------
   SHELL="$1"
RET_CODE="$2"
  NO_SCM="${3:-0}"
 COLUMNS="${4:-$(tput cols)}"

#-------------------------------------------------------------------------------
# Init
#-------------------------------------------------------------------------------
# Unalias all aliases
unalias -a

#-------------------------------------------------------------------------------
# Globals
#-------------------------------------------------------------------------------
CHECKOUT=""
AHEAD=""
BEHIND=""
STASHES=""
PORCELAIN_INFO=""
LOCAL_BRANCHES=""

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
# FANCY_PROMPT_DOUBLE_LINE
# FANCY_PROMPT_FETCH_TIMEOUT
# FANCY_PROMPT_RHS_ENABLE
# FANCY_PROMPT_TIMEOUT
# FANCY_PROMPT_USE_NERD_SYMBOLS
# FANCY_PROMPT_USE_SYMBOLS

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------
var_enabled() {
    [[ "$1" ]] && [[ $1 != 0 ]]
}

check_error() {
    RET_CODE="$1"
    CODE="$2"
    if [ "$RET_CODE" != 0 ]; then
        echo "ERROR $CODE:$RET_CODE"
        exit 1
    fi
}

in_git() {
    git rev-parse 2> /dev/null
    return $?
}

in_svn() {
    svn ls --depth empty > /dev/null 2>&1
    return $?
}

get_svn_local_rev() {
    info="$1"
    echo "$info" | grep 'Revision' | sed -E 's/Revision: ([0-9]+)/\1/'
}

get_svn_remote_rev() {
    info="$1"

    repo=$(echo "$info" | grep 'URL' | sed -E 's/URL: (.+)/\1/')

    remote_info=$(timeout "$TIMEOUT" svn info "$repo")
    check_error "$?" "10"

    echo "$remote_info" | grep 'Revision' | sed -E 's/Revision: ([0-9]+)/\1/'
}

vercomp() {
    local IFS=.
    local i

    # shellcheck disable=SC2206
    local ver1=($1)
    # shellcheck disable=SC2206
    local ver2=($2)

    if [[ "$1" == "$2" ]]; then
        return 0
    fi

    # fill empty fields in ver1 with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done
    for ((i=0; i<${#ver1[@]}; i++)); do
        if [[ -z ${ver2[i]} ]]; then
            # fill empty fields in ver2 with zeros
            ver2[i]=0
        fi
        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 0
        fi
    done
    return 1
}

git_bg_fetch() {
    if [[ -n $(git remote show) ]]; then
        local repo; repo=$(git rev-parse --show-toplevel 2> /dev/null)
        local fetch_head="$repo/.git/FETCH_HEAD"

        if [[ -e "$fetch_head" ]]; then
            local old_head

            old_head=$(find "$fetch_head" -mmin +"$FETCH_TIMEOUT" 2> /dev/null)

            if [[ -n "$old_head" ]]; then
                git fetch --quiet &> /dev/null
            fi
        fi
    fi
}

get_git_checkout() {
    local checkout
    local error
    local info="$1"
    local remote_abbr
    local remote_full
    local symbol=""

    checkout=$(\
        echo "$info" | \
        sed 's/\.\.\..*//g' | \
        sed -E 's/##[[:space:]]+//g' | \
        sed -n '1 p')

    error=$(check_error "$?" "5")

    if [[ "$checkout" =~ HEAD ]]; then
        # Show short hash if not on a branch
        checkout=$(git rev-parse --short HEAD)
        error=$(check_error "$?" "6")

        # Are we rebasing?
        if ls "$(git rev-parse --git-dir)"/rebase* > /dev/null 2>&1; then
            checkout="$checkout(rebasing)"
        fi
    fi

    remote_full=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}')

    remote_abbr=$(\
        echo "$remote_full" | \
        sed 's/^origin\///g' | \
        sed "s/$checkout$//g" )

    printf "%s" "$checkout"
    if ! [ -z "$remote_abbr" ]; then
        printf "%s" "->$remote_abbr"
    fi
}

set_git_info() {
    local info
    local git_version
    local error

    git_version=$(git --version | sed -E 's/git version ([0-9.]+)/\1/g')

    if vercomp "$git_version" "1.7.2"; then
        info=$(timeout "$TIMEOUT2" git status --untracked-files=normal --branch --porcelain "$GIT_STATUS_OPTS")
    else
        info=$(timeout "$TIMEOUT2" git status --untracked-files=normal --porcelain)
    fi

    error=$(check_error "$?" "2")

    PORCELAIN_INFO="$info"

    if [ "$error" == "" ]; then
         AHEAD=$(grep 'ahead'  <<< "$info" | sed -E  's/.*ahead[[:space:]]+([0-9]+).*/\1/g')
        BEHIND=$(grep 'behind' <<< "$info" | sed -E 's/.*behind[[:space:]]+([0-9]+).*/\1/g')
        error=$(check_error "$?" "4")

        if [ "$error" == "" ]; then
            STASHES=$(git stash list | wc -l)
            LOCAL_BRANCHES=$(git branch -vv | cut -c 3- | awk '$3 !~/\[origin/ { print $1 }' | wc -l)
            if vercomp "$git_version" "1.7.2"; then
                CHECKOUT=$(get_git_checkout "$info")
            else
                CHECKOUT="!$(git rev-parse --abbrev-ref HEAD)"
            fi
        fi
    fi

    git_bg_fetch &
}

set_svn_info() {
    local info
    local error

    info=$(timeout "$TIMEOUT" svn info)
    error=$(check_error "$?" "7")

    if [ "$error" == "" ]; then
        local local_rev
        local remote_rev

        local_rev=$(get_svn_local_rev "$info")
        remote_rev=$(get_svn_remote_rev "$info")

        if [[ $remote_rev =~ ^[0-9]+$ ]]; then
            BEHIND=$((remote_rev - local_rev))
        else
            error=$(check_error "1" "9")
        fi

        if PORCELAIN_INFO=$(timeout "$TIMEOUT" svn status 2> /dev/null); then
            PORCELAIN_INFO="?"
        fi

        CHECKOUT="r$local_rev"
    fi
}

get_scm_prompt() {
    local src_ctrl=""
    local staged=""
    local tree_deleted=""
    local index_deleted=""
    local unstaged=""
    local untracked="?"
    local conflicts=""

    if [ "$error" == "" ]; then
        # porcelain info should be common between git and svn
        if [ "$PORCELAIN_INFO" != "?" ]; then
            local staged=0
            local index_added=0
            local index_deleted=0
            local tree_deleted=0
            local unstaged=0
            local untracked=0
            local conflicts=0
            local unknown=0

            local IFS=$'\n'
            for line in $PORCELAIN_INFO; do
                if   [[ $line =~ ^##          ]]; then true
                elif [[ $line =~ ^[MRC][\ MD] ]]; then ((staged        ++))
                elif [[ $line =~ ^A[\ MD]     ]]; then ((index_added   ++))
                elif [[ $line =~ ^D\          ]]; then ((index_deleted ++))
                elif [[ $line =~ ^[\ MARC]D   ]]; then ((tree_deleted  ++))
                elif [[ $line =~ ^[\ MARC]M   ]]; then ((unstaged      ++))
                elif [[ $line =~ ^\?\?        ]]; then ((untracked     ++))
                elif [[ $line =~ ^(DD|AU|UD|UA|DU|AA|UU) ]]; then
                    # DD  unmerged, both deleted
                    # AU  unmerged, added by us
                    # UD  unmerged, deleted by them
                    # UA  unmerged, added by them
                    # DU  unmerged, deleted by us
                    # AA  unmerged, both added
                    # UU  unmerged, both modified
                    ((conflicts++))
                else
                    ((unknown++))
                fi
            done
        fi

        if var_enabled "$FANCY_PROMPT_USE_NERD_SYMBOLS"; then
            co_sym=""
        elif var_enabled "$FANCY_PROMPT_USE_SYMBOLS"; then
            co_sym=""
        fi

        build_section() {
            local colour=$1
            local symbol=$2
            local value=$3
            if { [[ $value ]] && [[ $value != 0 ]]; }; then
                echo "$colour$symbol$value"
            fi
        }

        src_ctrl+=$(build_section ""   "$co_sym" "$CHECKOUT"      )
        src_ctrl+=$(build_section "$white"   '↑' "$AHEAD"         )
        src_ctrl+=$(build_section "$white"   '↓' "$BEHIND"        )
        src_ctrl+=$(build_section "$green"   '●' "$staged"        )
        src_ctrl+=$(build_section "$green"   '+' "$index_added"   )
        src_ctrl+=$(build_section "$green"   '-' "$index_deleted" )
        src_ctrl+=$(build_section "$red"     '✖' "$conflicts"     )
        src_ctrl+=$(build_section "$red"     '+' "$unstaged"      )
        src_ctrl+=$(build_section "$red"     '-' "$tree_deleted"  )
        src_ctrl+=$(build_section "$magenta" '…' "$untracked"     )
        src_ctrl+=$(build_section "$yellow"  '⚑' "$STASHES"       )
        src_ctrl+=$(build_section "$yellow"  '!' "$LOCAL_BRANCHES")
        src_ctrl+=$(build_section "$magenta" '?' "$unknown"       )
    else
        src_ctrl+="$red$error"
    fi

    printf "%s" "${src_ctl_colour}[$src_ctrl$src_ctl_colour]"
}

remove_invisible_chars() {
    printf '%b' "$1" | sed 's/\\[\x1B\[[0-9;]*[a-zA-Z]\\]//g'
}

get_prompt_arrow() {
    if var_enabled "$FANCY_PROMPT_USE_SYMBOLS"; then
        if var_enabled "$FANCY_PROMPT_USE_NERD_SYMBOLS"; then
            #  
            arrow="❯"
        else
            arrow="▶"
        fi
    else
        arrow=">"
    fi

    echo "$ret_colour$arrow$end"
}

lhs_rhs_prompt() {
    local lhs=$1
    local rhs=$2
    local cols=$3
    local rhs_no_non_printable
    local rhs_length

    # Reference: https://en.wikipedia.org/wiki/ANSI_escape_code
    local save='\e[s' # Save cursor position
    local restore='\e[u' # Restore cursor to save point

    rhs_no_non_printable=$(remove_invisible_chars "$rhs")
    rhs_length=${#rhs_no_non_printable}

    printf "%s" "\\[${save}\\e[${cols}C\\e[${rhs_length}D${rhs}${restore}\\]${lhs}"
}

#-------------------------------------------------------------------------------
# Configuration
#-------------------------------------------------------------------------------
GIT_STATUS_OPTS="--ignore-submodules"
        TIMEOUT=${FANCY_PROMPT_TIMEOUT-3}
       TIMEOUT2=$((TIMEOUT*2))
  FETCH_TIMEOUT=${FANCY_PROMPT_FETCH_TIMEOUT-1}

if var_enabled "$FANCY_PROMPT_USE_NERD_SYMBOLS"; then
    FANCY_PROMPT_USE_SYMBOLS=1
fi

#-------------------------------------------------------------------------------
# Attributes & Colours
#-------------------------------------------------------------------------------
if [ "$SHELL" == "bash" ]; then
    c_start='\['
      c_end='\]'
       user='\u'
        dir='\W'
       host='\H'
else # csh, tcsh and zsh
    c_start='%{'
      c_end='%}'
       user='%n'
        dir='%c'
       host='%m'
fi

   # reverse="${c_start}\\e[3;35m${c_end}"
# underlined="${c_start}\\e[4;35m${c_end}"
       # dim="${c_start}\\e[10;35m${c_end}"
      gray="$c_start\\e[1;30m$c_end"
       red="$c_start\\e[1;31m$c_end"
     green="$c_start\\e[1;32m$c_end"
    yellow="$c_start\\e[1;33m$c_end"
      blue="$c_start\\e[1;34m$c_end"
   magenta="$c_start\\e[1;35m$c_end"
      cyan="$c_start\\e[1;36m$c_end"
     white="$c_start\\e[1;37m$c_end"
       end="$c_start\\e[0m$c_end" # This is needed at the end.

# Use a different colour for each shell.

case "$SHELL" in
    bash) dir_colour="$yellow"  ;;
    zsh)  dir_colour="$green"   ;;
    *)    dir_colour="$magenta" ;;
esac

src_ctl_colour="$gray"

#-------------------------------------------------------------------------------
# Source Control
#-------------------------------------------------------------------------------

# If we a located somewhere deep in .git/.. then navigate out of it to prevent
# the error: "fatal: This operation must be run in a work tree"
if pwd | grep -q "\\.git"; then
    cd "$(pwd | sed -E 's/\.git(\/.*)?//g')" || exit
fi

prompt_info=""
if ((NO_SCM == 0)); then
    if in_git; then
        set_git_info
        prompt_info=$(get_scm_prompt)
    elif in_svn; then
        set_svn_info
        prompt_info=$(get_scm_prompt)
    fi
fi

#-------------------------------------------------------------------------------
# Prompt
#-------------------------------------------------------------------------------
prompt=""

# Adjust prompt according on terminal width.
if [[ $COLUMNS -gt 40 ]] || ! var_enabled "$FANCY_PROMPT_DYNAMIC_WIDTH"; then
    if [[ $COLUMNS -gt 80 ]] || ! var_enabled "$FANCY_PROMPT_DYNAMIC_WIDTH"; then
        prompt+="$blue"
        prompt+="$host:"
        prompt+="$cyan"
        prompt+="$user:"
    fi
    prompt+="$dir_colour"
    prompt+="$dir"
fi

if [ "$RET_CODE" == 0 ]; then
    ret_colour="$cyan"
else
    ret_colour="$red"
fi

prompt_end="$(get_prompt_arrow) "

if var_enabled "$FANCY_PROMPT_DOUBLE_LINE"; then
    printf "%s" "\\n$prompt$prompt_info\\n$prompt_end"
elif var_enabled "$FANCY_PROMPT_RHS_ENABLE"; then
    # TODO: This is buggy when using completion
    # TODO: Does not work for zsh
    lhs_rhs_prompt "$prompt$prompt_end" "$prompt_info" "$cols"
else
    printf "%s" "$prompt$prompt_info$prompt_end"
fi
